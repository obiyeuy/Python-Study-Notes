# 正则表达式是⼀组由字⺟和符号组成的特殊⽂本，它可以⽤来从⽂本中找出满⾜你想要的格式的句⼦。
# ⼀个正则表达式是⼀种从左到右匹配主体字符串的模式。
# “Regular expression”这个词⽐较拗⼝，我们常使⽤缩写的术语“regex”或“regexp”。
# 正则表达式可以从⼀个基础字符串中根据⼀定的匹配模式替换⽂本中的字符串、验证表单、提取字符串等等。

import re

msg = '佟丽娅娜扎热巴'

pattern = re.compile('佟丽娅')
result = pattern.match(msg)  # 从头开始匹配，没有匹配就没有返回值:None
print(result)  # 匹配成功即返回:<re.Match object; span=(0, 3), match='佟丽娅'>

# 使用正则模块方法：match
s = '娜扎热巴佟丽娅'
result = re.match('佟丽娅', s)
print(result)

result = re.search('佟丽娅', s)  # 只要有就匹配成功
print(result)  # <re.Match object; span=(4, 7), match='佟丽娅'>

print(result.span())  # 返回位置:(4, 7)

print(result.group())  # 返回提取到的内容:佟丽娅
print(result.groups())

# 使用正则符号
"""
表 示 法 	描 述 	正则表达式示例
符号		
literal 	匹配文本字符串的字面值 literal 	foo
re1|re2 	匹配正则表达式 re1 或者 re2 	foo|bar
. 	匹配任何字符（除了\n 之外） 	b.b
^ 	匹配字符串起始部分 	^Dear
$ 	匹配字符串终止部分 	/bin/*sh$
* 	匹配 0 次或者多次前面出现的正则表达式 	[A-Za-z0-9]*
+ 	匹配 1 次或者多次前面出现的正则表达式 	[a-z]+ \.com
? 	匹配 0 次或者 1 次前面出现的正则表达式 	goo?
{N} 	匹配 N 次前面出现的正则表达式 	[0-9]{3}
{M,N} 	匹配 M～N 次前面出现的正则表达式 	[0-9]{5,9}
[…] 	匹配来自字符集的任意单一字符 	[aeiou]
[..x-y..] 	匹配 x～y 范围中的任意单一字符 	[0-9], [A-Za-z]
[^…] 	不匹配此字符集中出现的任何一个字符，包括某一范围的字符（如果在此字符集中出现） 	[^aeiou], [^A-Za-z0-9]
(*|+|?|{})? 	用于匹配上面频繁出现/重复出现符号的非贪婪版本（*、 +、 ?、 {}） 	.*?[a-z]
(…) 	匹配封闭的正则表达式，然后另存为子组 	([0-9]{3})?,f(oo|u)bar   
\d 	匹配任何十进制数字，与[0-9]一致（ \D 与\d 相反，不匹配任何非数值型的数字） 	data\d+.txt
\w 	匹配任何字母数字字符，与[A-Za-z0-9_]相同（ \W 与之相反） 	[A-Za-z_]\w+
\s 	匹配任何空格字符，与[\n\t\r\v\f]相同（ \S 与之相反） 	of\sthe
\b 	匹配任何单词边界（ \B 与之相反） 	\bThe\b
\c 	逐字匹配任何特殊字符 c（即，仅按照字面意义匹配，不匹配特殊含义） 	\., \\, \*
\A(\Z) 	匹配字符串的起始（结束）（ 另见上面介绍的^和$） 	\ADear

扩展表示法		
表 示 法 	描 述 	正则表达式示例
(?iLmsux) 	在正则表达式中嵌入一个或者多个特殊“ 标记” 参数（或者通过函数/方法） 	（ ?x），（？ im）
(?:…) 	表示一个匹配不用保存的分组 	(?:\w+\.)*
(?P<name>…) 	像一个仅由 name 标识而不是数字 ID 标识的正则分组匹配 	(?P<data>)
(?P=name) 	在同一字符串中匹配由(?P<name)分组的之前文本 	(?P=data)
(?#…) 	表示注释，所有内容都被忽略 	(?#comment)
(?=…) 	匹配条件是如果…出现在之后的位置，而不使用输入字符串；称作正向前视断言 	(?=.com)
(?!…) 	匹配条件是如果…不出现在之后的位置，而不使用输入字符串；称作负向前视断言 	(?!.net)
(?<=…) 	匹配条件是如果…出现在之前的位置，而不使用输入字符串；称作正向后视断言 	(?<=800-)
(?<!…) 	匹配条件是如果…不出现在之前的位置，而不使用输入字符串；称作负向后视断言 	(?<!192\.168\.)
(?(id/name)Y|N ) 	如果分组所提供的 id 或者 name（名称）存在，就返回正则表达式的条件匹配 Y，如
果不存在，就返回 N； |N 是可选项	(?(1)y|x)



"""
# a2d  e5f
msg = 'jg387uhfeg438y743ghre8gh3gjk'
result = re.search('[a-z][0-9][a-z]', msg)  # 只找第一个
print(result.group())  # 只返回第一个搜索到的
result = re.findall('[a-z][0-9][a-z]', msg)  # 从左到右找，放在列表中(有可能找不完)e.g.re3h4j只会找出e3h
print(result)

result = re.findall('[a-z][0-9]+[a-z]', msg)  # 从左到右找，放在列表中(有可能找不完)e.g.re3h4j只会找出e3h
print(result)

# qq验证
qq = '113245432'
result = re.match('^[1-9][0-9]{4,10}$', qq)  # 从左到右找，放在列表中(有可能找不完)e.g.re3h4j只会找出e3h
print(result)












